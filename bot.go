package main

import (
	"bytes"
	"context"
	"emoji-generator/db"
	"fmt"
	"log/slog"
	"os"
	"slices"
	"strconv"
	"strings"
	"time"

	tgbotapi "github.com/OvyFlash/telegram-bot-api"

	"github.com/cavaliergopher/grab/v3"
	"github.com/go-telegram/bot"
	"github.com/go-telegram/bot/models"
)

var validchatIDs = []int64{-1002400904088, -1002400904088_3}

func validchatID(next bot.HandlerFunc) bot.HandlerFunc {
	return func(ctx context.Context, b *bot.Bot, update *models.Update) {
		for _, chatID := range validchatIDs {
			if chatID == update.Message.Chat.ID {
				next(ctx, b, update)
				return
			}
		}
	}
}

func handler(ctx context.Context, b *bot.Bot, update *models.Update) {
	if update.Message == nil {
		return
	}

	for i, chatID := range validchatIDs {
		if chatID == update.Message.Chat.ID {
			break
		}
		if i == len(validchatIDs)-1 {
			return
		}
	}

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥–æ–π
	if strings.HasPrefix(update.Message.Text, "/emoji") {
		handleEmojiCommand(ctx, b, update)
	} else if update.Message.Text == "/emoji" {
		handleEmojiCommand(ctx, b, update)
	} else if strings.HasPrefix(update.Message.Caption, "/emoji ") {
		handleEmojiCommand(ctx, b, update)
	} else if update.Message.Caption == "/emoji " {
		handleEmojiCommand(ctx, b, update)
	} else if update.Message.Text == "/info" {
		handleInfoCommand(ctx, b, update)
	}
}

func handleInfoCommand(ctx context.Context, b *bot.Bot, update *models.Update) {

	infoText := `ü§ñ –ë–æ—Ç –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —ç–º–æ–¥–∑–∏-–ø–∞–∫–æ–≤ –∏–∑ –∫–∞—Ä—Ç–∏–Ω–æ–∫/–≤–∏–¥–µ–æ/GIF

–û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª —Å –∫–æ–º–∞–Ω–¥–æ–π /emoji –∏ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ param=[value]:

–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
‚Ä¢ width=[N] –∏–ª–∏ w=[N] - —à–∏—Ä–∏–Ω–∞ –Ω–∞—Ä–µ–∑–∫–∏ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 8). –ß–µ–º –º–µ–Ω—å—à–µ —à–∏—Ä–∏–Ω–∞, —Ç–µ–º –∫—Ä—É–ø–Ω–µ–µ —ç–º–æ–¥–∑–∏
‚Ä¢ background=[—Ü–≤–µ—Ç] –∏–ª–∏ b=[—Ü–≤–µ—Ç] - —Ü–≤–µ—Ç —Ñ–æ–Ω–∞, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –≤—ã—Ä–µ–∑–∞–Ω –∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è:
  - HEX —Ñ–æ—Ä–º–∞—Ç: b=[0x00FF00]
  - –ù–∞–∑–≤–∞–Ω–∏—è: b=[black], b=[white], b=[pink], b=[green]
‚Ä¢ b_sim=[—á–∏—Å–ª–æ] - –ø–æ—Ä–æ–≥ —Å—Ö–æ–∂–µ—Å—Ç–∏ —Ü–≤–µ—Ç–∞ —Å —Ñ–æ–Ω–æ–º (0-1, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 0.1)
‚Ä¢ b_blend=[—á–∏—Å–ª–æ] - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–º–µ—à–∏–≤–∞–Ω–∏–µ —Ü–≤–µ—Ç–æ–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ñ–æ–Ω–∞ (0-1, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 0.1)
‚Ä¢ link=[—Å—Å—ã–ª–∫–∞] –∏–ª–∏ l=[—Å—Å—ã–ª–∫–∞] - –¥–æ–±–∞–≤–∏—Ç—å —ç–º–æ–¥–∑–∏ –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ø–∞–∫ (–¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å–æ–∑–¥–∞–Ω –≤–∞–º–∏)
‚Ä¢ iphone=[true] –∏–ª–∏ i=[true] - –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ä–∞–∑–º–µ—Ä–∞ –ø–æ–¥ iPhone`

	_, err := b.SendMessage(ctx, &bot.SendMessageParams{
		ReplyParameters: &models.ReplyParameters{

			MessageID: update.Message.ID,
			ChatID:    update.Message.Chat.ID,
		},
		ChatID: update.Message.Chat.ID,
		Text:   infoText,
	})
	if err != nil {
		slog.Error("Failed to send info message", slog.String("err", err.Error()))
	}
}

const (
	defaultWidth           = 8
	defaultBackgroundSim   = "0.1"
	defaultBackgroundBlend = "0.1"
	defaultStickerFormat   = "video"
	defaultEmojiIcon       = "üé•"
	maxStickersInBatch     = 50
	maxStickersTotal       = 200
)

func handleEmojiCommand(ctx context.Context, b *bot.Bot, update *models.Update) {
	// Extract command arguments
	args := extractCommandArgs(update.Message)
	emojiArgs, err := parseArgs(args)
	if err != nil {
		slog.Error("Invalid arguments", slog.String("err", err.Error()))
		sendErrorMessage(ctx, b, update, update.Message.Chat.ID, err.Error())
		return
	}

	// Setup command defaults and working environment
	setupEmojiCommand(emojiArgs, update.Message)

	// Get bot info and setup pack details
	botInfo, err := b.GetMe(ctx)
	if err != nil {
		slog.Error("Failed to get bot info", slog.String("err", err.Error()))
		sendErrorMessage(ctx, b, update, update.Message.Chat.ID, "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–æ—Ç–µ")
		return
	}

	emojiPack, err := setupPackDetails(ctx, emojiArgs, botInfo)
	if err != nil {
		slog.Error("Failed to setup pack details", slog.String("err", err.Error()))
		sendErrorMessage(ctx, b, update, update.Message.Chat.ID, "–ø–∞–∫ —Å –ø–æ–¥–æ–±–Ω–æ–π —Å—Å—ã–ª–∫–æ–π –Ω–µ –Ω–∞–π–¥–µ–Ω")
		return
	}

	pgBot, err := db.Postgres.GetBotByName(ctx, botInfo.Username)
	if err != nil {
		slog.Error("Failed to get bot by name", slog.String("err", err.Error()))
		sendErrorMessage(ctx, b, update, update.Message.Chat.ID, "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–æ—Ç–µ")
		return
	}

	if emojiPack == nil {
		// Create database record
		emojiPack, err = createDatabaseRecord(ctx, emojiArgs, args, pgBot.Name)
		if err != nil {
			slog.Error("Failed to log emoji command",
				slog.String("err", err.Error()),
				slog.String("pack_link", emojiArgs.PackLink),
				slog.Int64("user_id", emojiArgs.UserID))
			sendErrorMessage(ctx, b, update, update.Message.Chat.ID, "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∑–∞–ø–∏—Å—å –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö")
			return
		}
	}

	// Create working directory and download file
	if err := prepareWorkingEnvironment(ctx, b, update, emojiArgs); err != nil {
		handleDownloadError(ctx, b, update, err)
		return
	}

	// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤–∏–¥–µ–æ
	createdFiles, err := processVideo(emojiArgs)
	if err != nil {
		slog.LogAttrs(ctx, slog.LevelError, "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∏–¥–µ–æ", emojiArgs.ToSlogAttributes(slog.String("err", err.Error()))...)
		removeDirectory(emojiArgs.WorkingDir)
		sendErrorMessage(ctx, b, update, update.Message.Chat.ID, fmt.Sprintf("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∏–¥–µ–æ: %s", err.Error()))
		return
	}

	// –°–æ–∑–¥–∞–µ–º –Ω–∞–±–æ—Ä —Å—Ç–∏–∫–µ—Ä–æ–≤
	stickerSet, err := addEmojis(ctx, b, emojiArgs, createdFiles)
	if err != nil {
		if strings.Contains(err.Error(), "PEER_ID_INVALID") || strings.Contains(err.Error(), "user not found") || strings.Contains(err.Error(), "bot was blocked by the user") {
			inlineKeyboard := tgbotapi.NewInlineKeyboardButtonURL("/start", fmt.Sprintf("t.me/%s?start=start", tgbotApi.Self.UserName))
			row := tgbotapi.NewInlineKeyboardRow(inlineKeyboard)
			keyboard := tgbotapi.NewInlineKeyboardMarkup(row)
			msg := tgbotapi.NewMessage(update.Message.Chat.ID, fmt.Sprintf("–ß—Ç–æ–±—ã –±–æ—Ç –º–æ–≥ —Å–æ–∑–¥–∞—Ç—å –ø–∞–∫ \n–Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ\n‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì"))
			msg.ReplyMarkup = keyboard
			msg.ParseMode = "MarkdownV2"
			msg.ReplyParameters = tgbotapi.ReplyParameters{
				MessageID: update.Message.ID,
				ChatID:    update.Message.Chat.ID,
			}

			_, err2 := tgbotApi.Send(msg)
			if err2 != nil {
				slog.Error("Failed to send message with emojis", slog.String("username", update.Message.From.Username), slog.Int64("user_id", update.Message.From.ID), slog.String("err2", err2.Error()))
			}

			return

		}
		sendErrorMessage(ctx, b, update, update.Message.Chat.ID, fmt.Sprintf("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–∞–±–æ—Ä–∞ —Å—Ç–∏–∫–µ—Ä–æ–≤: %s", err.Error()))
		return
	}

	// –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–º–æ–¥–∑–∏ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
	if err := db.Postgres.SetEmojiCount(ctx, emojiPack.ID, len(stickerSet.Stickers)); err != nil {
		slog.Error("Failed to update emoji count",
			slog.String("err", err.Error()),
			slog.String("pack_link", emojiArgs.PackLink),
			slog.Int64("user_id", emojiArgs.UserID))
	}

	// –°–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–æ–º–ø–æ–∑–∏—Ü–∏–µ–π —ç–º–æ–¥–∑–∏
	messageText := ""
	entities := make([]models.MessageEntity, 0, len(stickerSet.Stickers))

	offset := 0
	emojiIndex := 0
	for i, sticker := range stickerSet.Stickers {
		if i == 99 {
			break
		}
		if i+1%emojiArgs.Width == 0 {
			messageText += "üé•\n"
		} else {
			messageText += "üé•"
		}

		// –î–æ–±–∞–≤–ª—è–µ–º –≤ entities —Ç–æ–ª—å–∫–æ —Ä–µ–∞–ª—å–Ω—ã–µ —ç–º–æ–¥–∑–∏ (–Ω–µ –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–µ)
		pos := i % defaultWidth
		isTransparent := false

		if emojiArgs.Width < defaultWidth {
			leftPadding := (defaultWidth - emojiArgs.Width) / 2
			rightPadding := defaultWidth - emojiArgs.Width - leftPadding
			isTransparent = pos < leftPadding || pos >= (defaultWidth-rightPadding)
		}

		if !isTransparent {
			entities = append(entities, models.MessageEntity{
				Type:          "custom_emoji",
				Offset:        offset,
				Length:        2,
				CustomEmojiID: sticker.CustomEmojiID,
			})
			emojiIndex++
		}

		if i+1%emojiArgs.Width == 0 {
			offset += 3 // 2 for emoji + 1 for newline
		} else {
			offset += 2 // 2 for emoji
		}
	}

	// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –ø–∞–∫
	topicId := fmt.Sprintf("%d_%d", update.Message.Chat.ID, update.Message.MessageThreadID)
	//_, err = b.SendMessage(ctx, &bot.SendMessageParams{
	//	ChatID:          update.Message.Chat.ID,
	//	MessageThreadID: update.Message.MessageThreadID,
	//	Text:            fmt.Sprintf("–°—Å—ã–ª–∫–∞ –Ω–∞ –ø–∞–∫ —Å —ç–º–æ–¥–∑–∏: https://t.me/addemoji/%s", emojiArgs.PackLink),
	//})
	//message := bot.SendMessageParams{
	//	ChatID:          update.Message.Chat.ID,
	//	MessageThreadID: update.Message.MessageThreadID,
	//	Text:            fmt.Sprintf("https://t.me/addemoji/%s", emojiArgs.PackLink),
	//	ReplyParameters: &models.ReplyParameters{
	//		MessageID: update.Message.ID,
	//		ChatID:    update.Message.Chat.ID,
	//	},
	//}
	//err = userBot.SendMessage(ctx, topicId, message)
	//if err != nil {
	//	slog.Error("Failed to send message with emojis pack link", slog.String("err", err.Error()))
	//}

	// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —ç–º–æ–¥–∑–∏
	message := bot.SendMessageParams{
		ChatID:          update.Message.Chat.ID,
		MessageThreadID: update.Message.MessageThreadID,
		Text:            fmt.Sprintf("", messageText),
		Entities:        entities,
		ReplyParameters: &models.ReplyParameters{
			MessageID: update.Message.ID,
			ChatID:    update.Message.Chat.ID,
		},
	}

	err = userBot.SendMessageWithEmojis(ctx, topicId, emojiArgs.Width, emojiArgs.PackLink, emojiArgs.RawInitCommand, message)
	if err != nil {
		slog.Error("Failed to send message with emojis", slog.String("err", err.Error()), slog.String("username", update.Message.From.Username), slog.Int64("user_id", update.Message.From.ID))
	}
}

func sendErrorMessage(ctx context.Context, b *bot.Bot, u *models.Update, chatID int64, errToSend string) {
	_, err := b.SendMessage(ctx, &bot.SendMessageParams{
		ReplyParameters: &models.ReplyParameters{
			MessageID: u.Message.ID,
			ChatID:    u.Message.Chat.ID,
		},
		ChatID: chatID,
		Text:   fmt.Sprintf("–í–æ–∑–Ω–∏–∫–ª–∞ –æ—à–∏–±–∫–∞: %s", errToSend),
	})
	if err != nil {
		slog.Error("Failed to send error message", slog.String("err", err.Error()))
	}
}

func extractCommandArgs(msg *models.Message) string {
	var args string
	if strings.HasPrefix(msg.Text, "/emoji") {
		args = strings.TrimPrefix(msg.Text, "/emoji")
	} else if strings.HasPrefix(msg.Caption, "/emoji ") {
		args = strings.TrimPrefix(msg.Caption, "/emoji ")
	}
	return strings.TrimSpace(args)
}

func setupEmojiCommand(args *EmojiCommand, msg *models.Message) {
	// Set default values
	if args.Width == 0 {
		args.Width = defaultWidth
	}
	if args.BackgroundSim == "" {
		args.BackgroundSim = defaultBackgroundSim
	}
	if args.BackgroundBlend == "" {
		args.BackgroundBlend = defaultBackgroundBlend
	}
	if args.SetName == "" {
		args.SetName = strings.TrimSpace(PackTitleTempl)
	} else {
		if len(args.SetName) > TelegramPackLinkAndNameLength-len(PackTitleTempl) {
			args.SetName = args.SetName[:TelegramPackLinkAndNameLength-len(PackTitleTempl)]
		}
		args.SetName = args.SetName + " " + PackTitleTempl
	}

	// Setup working directory and user info
	postfix := fmt.Sprintf("%d_%d", msg.From.ID, time.Now().Unix())
	args.WorkingDir = fmt.Sprintf(outputDirTemplate, postfix)

	args.UserID = msg.From.ID
	if msg.From.IsBot || msg.From.ID < 0 {
		args.UserID = 251636949
	}
	args.UserName = msg.From.Username
}

func setupPackDetails(ctx context.Context, args *EmojiCommand, botInfo *models.User) (*db.EmojiPack, error) {
	if strings.Contains(args.PackLink, botInfo.Username) {
		return handleExistingPack(ctx, args)
	}
	return nil, handleNewPack(args, botInfo)
}

func handleExistingPack(ctx context.Context, args *EmojiCommand) (*db.EmojiPack, error) {
	args.newSet = false
	if strings.Contains(args.PackLink, "t.me/addemoji/") {
		splited := strings.Split(args.PackLink, ".me/addemoji/")
		args.PackLink = strings.TrimSpace(splited[len(splited)-1])
	}

	pack, err := db.Postgres.GetEmojiPackByPackLink(ctx, args.PackLink)
	if err != nil {
		return nil, err
	}
	args.SetName = ""
	return pack, nil
}

func handleNewPack(args *EmojiCommand, botInfo *models.User) error {
	args.newSet = true
	packName := fmt.Sprintf("%s%d_by_%s", "dt", time.Now().Unix(), botInfo.Username)
	if len(packName) > TelegramPackLinkAndNameLength {
		args.PackLink = args.PackLink[:len(packName)-TelegramPackLinkAndNameLength]
		packName = fmt.Sprintf("%s_%s", args.PackLink, botInfo.Username)
	}
	args.PackLink = packName
	return nil
}

func createDatabaseRecord(ctx context.Context, args *EmojiCommand, initialCommand string, botUsername string) (*db.EmojiPack, error) {
	emojiPack := &db.EmojiPack{
		CreatorID:      args.UserID,
		PackName:       args.SetName,
		PackLink:       &args.PackLink,
		InitialCommand: &initialCommand,
		BotName:        botUsername,
		EmojiCount:     0,
	}
	return db.Postgres.LogEmojiCommand(ctx, emojiPack)
}

func prepareWorkingEnvironment(ctx context.Context, b *bot.Bot, update *models.Update, args *EmojiCommand) error {
	if err := os.MkdirAll(args.WorkingDir, 0755); err != nil {
		return fmt.Errorf("failed to create working directory: %w", err)
	}

	fileName, err := downloadFile(ctx, b, update.Message, args)
	if err != nil {
		return err
	}
	args.DownloadedFile = fileName
	return nil
}

func handleDownloadError(ctx context.Context, b *bot.Bot, update *models.Update, err error) {
	slog.Error("Failed to download file", slog.String("err", err.Error()))
	var message string
	switch err {
	case ErrFileOfInvalidType:
		message = "–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø —Ñ–∞–π–ª–∞. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è: GIF, JPEG, PNG, WebP, MP4, WebM, MPEG"
	case ErrGetFileFromTelegram:
		message = "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ñ–∞–π–ª –∏–∑ Telegram"
	case ErrFileDownloadFailed:
		message = "–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞"
	default:
		message = "–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞"
	}
	sendErrorMessage(ctx, b, update, update.Message.Chat.ID, message)
}

func parseArgs(arg string) (*EmojiCommand, error) {
	var emojiArgs EmojiCommand
	emojiArgs.RawInitCommand = "/emoji " + arg
	// –†–∞–∑–±–∏–≤–∞–µ–º —Å—Ç—Ä–æ–∫—É –Ω–∞ —á–∞—Å—Ç–∏, —É—á–∏—Ç—ã–≤–∞—è –∫–∞–∫ –ø—Ä–æ–±–µ–ª—ã, —Ç–∞–∫ –∏ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã –≤ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö —Å–∫–æ–±–∫–∞—Ö
	var args []string
	parts := strings.Fields(arg)

	for _, part := range parts {
		if strings.Contains(part, "[") && strings.Contains(part, "]") {
			// –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–º—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∏ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —Ñ–æ—Ä–º–∞—Ç–∞ param=[value]
			paramStart := strings.Index(part, "=")
			if paramStart == -1 {
				continue
			}

			key := strings.ToLower(part[:paramStart])
			// –ò–∑–≤–ª–µ–∫–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –º–µ–∂–¥—É [ –∏ ]
			valueStart := strings.Index(part, "[")
			valueEnd := strings.Index(part, "]")
			if valueStart == -1 || valueEnd == -1 || valueStart >= valueEnd {
				slog.Error("Invalid arguments", slog.String("err", "Invalid format"), slog.String("arg", part))
				continue
			}
			value := part[valueStart+1 : valueEnd]
			args = append(args, key+"="+value)
		} else {
			// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ–±—ã—á–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç param=value
			args = append(args, part)
		}
	}

	for _, arg := range args {
		parts := strings.SplitN(arg, "=", 2)
		if len(parts) != 2 {
			continue // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∞—Ä–≥—É–º–µ–Ω—Ç
		}

		key := strings.ToLower(parts[0])
		value := parts[1]

		// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∫–ª—é—á –∏–∑ –∞–ª–∏–∞—Å–∞
		standardKey, exists := argAlias[key]
		if !exists {
			continue // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∞—Ä–≥—É–º–µ–Ω—Ç
		}

		// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞
		switch standardKey {
		case "width":
			width, err := strconv.Atoi(value)
			if err != nil {
				continue
			}
			emojiArgs.Width = width
		case "background":
			emojiArgs.BackgroundColor = ColorToHex(value)
		case "background_blend":
			value = strings.ReplaceAll(value, ",", ".")
			emojiArgs.BackgroundBlend = value
		case "background_sim":
			value = strings.ReplaceAll(value, ",", ".")
			emojiArgs.BackgroundSim = value
		case "link":
			emojiArgs.PackLink = value
		case "iphone":
			if value != "true" && value != "false" {
				continue
			}
			emojiArgs.Iphone = value == "true"
		}
	}

	return &emojiArgs, nil
}

func downloadFile(ctx context.Context, b *bot.Bot, m *models.Message, args *EmojiCommand) (string, error) {
	var fileID string
	var fileExt string
	var mimeType string

	if m.Video != nil {
		fileID = m.Video.FileID
		mimeType = m.Video.MimeType
	} else if m.Photo != nil && len(m.Photo) > 0 {
		fileID = m.Photo[len(m.Photo)-1].FileID
		mimeType = "image/jpeg"
	} else if m.Document != nil {
		if slices.Contains(allowedMimeTypes, m.Document.MimeType) {
			fileID = m.Document.FileID
			mimeType = m.Document.MimeType
		} else {
			return "", ErrFileOfInvalidType
		}
	} else if m.ReplyToMessage != nil {
		if m.ReplyToMessage.Video != nil {
			fileID = m.ReplyToMessage.Video.FileID
			mimeType = m.ReplyToMessage.Video.MimeType
		} else if m.ReplyToMessage.Photo != nil && len(m.ReplyToMessage.Photo) > 0 {
			fileID = m.ReplyToMessage.Photo[len(m.ReplyToMessage.Photo)-1].FileID
			mimeType = "image/jpeg"
		} else if m.ReplyToMessage.Document != nil {
			fileID = m.ReplyToMessage.Document.FileID
			mimeType = m.ReplyToMessage.Document.MimeType
		}
	}

	file, err := b.GetFile(ctx, &bot.GetFileParams{FileID: fileID})
	if err != nil {
		return "", fmt.Errorf("%w: %w", ErrGetFileFromTelegram, err)
	}
	args.File = file

	switch mimeType {
	case "image/gif":
		fileExt = ".gif"
	case "image/jpeg":
		fileExt = ".jpg"
	case "image/png":
		fileExt = ".png"
	case "image/webp":
		fileExt = ".webp"
	case "video/mp4":
		fileExt = ".mp4"
	case "video/webm":
		fileExt = ".webm"
	case "video/mpeg":
		fileExt = ".mpeg"
	default:
		return "", ErrFileOfInvalidType
	}

	fileURL := fmt.Sprintf("https://api.telegram.org/file/bot%s/%s", os.Getenv("BOT_TOKEN"), file.FilePath)
	resp, err := grab.Get(args.WorkingDir+"/saved"+fileExt, fileURL)
	if err != nil {
		return "", fmt.Errorf("%w: %w", ErrFileDownloadFailed, err)
	}

	return resp.Filename, nil
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏
func handleTelegramError(err error) (int, error) {
	if err == nil {
		return 0, nil
	}

	if strings.Contains(err.Error(), "retry_after") {
		// –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –∏–∑ –æ—à–∏–±–∫–∏
		parts := strings.Split(err.Error(), "retry_after ")
		slog.Debug("handleTelegramError", slog.String("err", err.Error()), slog.String("parts", strings.Join(parts, " /// ")))
		if len(parts) >= 2 {
			if waitTime, parseErr := strconv.Atoi(strings.TrimSpace(parts[1])); parseErr == nil {
				return waitTime + 5, nil
			}
		}
	}
	return 0, err
}

func uploadSticker(ctx context.Context, b *bot.Bot, userID int64, filename string, data []byte) (string, error) {
	for {
		newSticker, err := b.UploadStickerFile(ctx, &bot.UploadStickerFileParams{
			UserID: userID,
			Sticker: &models.InputFileUpload{
				Filename: filename,
				Data:     bytes.NewReader(data),
			},
			StickerFormat: defaultStickerFormat,
		})

		if err != nil {
			slog.Debug("upload sticker FAILED",
				slog.String("file", filename),
				slog.String("err", err.Error()))
		} else {
			slog.Debug("upload sticker SUCCESS",
				slog.String("file", filename))
		}

		if waitTime, err := handleTelegramError(err); err != nil {
			return "", fmt.Errorf("upload sticker: %w", err)
		} else if waitTime > 0 {
			slog.Info("waiting before retry", "seconds", waitTime)
			time.Sleep(time.Duration(waitTime) * time.Second)
			continue
		}

		return newSticker.FileID, nil
	}
}

func addEmojis(ctx context.Context, b *bot.Bot, args *EmojiCommand, emojiFiles []string) (*models.StickerSet, error) {
	if err := validateEmojiFiles(emojiFiles); err != nil {
		return nil, err
	}

	// –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–µ —Å—Ç–∏–∫–µ—Ä—ã –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
	transparentData, err := prepareTransparentData(args.Width)
	if err != nil {
		return nil, err
	}

	// –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ —ç–º–æ–¥–∑–∏ —Å—Ç–∏–∫–µ—Ä—ã
	emojiFileIDs, err := uploadEmojiFiles(ctx, b, args, emojiFiles)
	if err != nil {
		return nil, err
	}

	if args.newSet {
		return createNewStickerSet(ctx, b, args, emojiFileIDs, transparentData)
	}

	return addToExistingStickerSet(ctx, b, args, emojiFileIDs, transparentData)
}

// validateEmojiFiles –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –≤—Ö–æ–¥–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
func validateEmojiFiles(emojiFiles []string) error {
	if len(emojiFiles) == 0 {
		return fmt.Errorf("–Ω–µ—Ç —Ñ–∞–π–ª–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–∞–±–æ—Ä–∞")
	}

	if len(emojiFiles) > maxStickersTotal {
		return fmt.Errorf("—Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —Ñ–∞–π–ª–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–∞–±–æ—Ä–∞ (–º–∞–∫—Å–∏–º—É–º %d)", maxStickersTotal)
	}

	return nil
}

// prepareTransparentData –ø–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ–≥–æ —Å—Ç–∏–∫–µ—Ä–∞ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
func prepareTransparentData(width int) ([]byte, error) {
	transparentSpacing := defaultWidth - width
	if transparentSpacing <= 0 {
		return nil, nil
	}

	transparentData, err := os.ReadFile("transparent.webm")
	if err != nil {
		return nil, fmt.Errorf("open transparent file: %w", err)
	}

	return transparentData, nil
}

// uploadEmojiFiles –∑–∞–≥—Ä—É–∂–∞–µ—Ç –≤—Å–µ —Ñ–∞–π–ª—ã —ç–º–æ–¥–∑–∏ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏—Ö fileIDs
func uploadEmojiFiles(ctx context.Context, b *bot.Bot, args *EmojiCommand, emojiFiles []string) ([]string, error) {
	slog.Debug("uploading emoji stickers", slog.Int("count", len(emojiFiles)))
	emojiFileIDs := make([]string, len(emojiFiles))

	for i, emojiFile := range emojiFiles {
		fileData, err := os.ReadFile(emojiFile)
		if err != nil {
			return nil, fmt.Errorf("open emoji file: %w", err)
		}

		fileID, err := uploadSticker(ctx, b, args.UserID, emojiFile, fileData)
		if err != nil {
			return nil, err
		}
		emojiFileIDs[i] = fileID

		time.Sleep(time.Millisecond * 50)
	}

	return emojiFileIDs, nil
}

// createNewStickerSet —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π –Ω–∞–±–æ—Ä —Å—Ç–∏–∫–µ—Ä–æ–≤ —Å –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º–∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏
func createNewStickerSet(ctx context.Context, b *bot.Bot, args *EmojiCommand, emojiFileIDs []string, transparentData []byte) (*models.StickerSet, error) {
	totalEmojis := len(emojiFileIDs)
	rows := (totalEmojis + args.Width - 1) / args.Width
	totalWithTransparent := rows * defaultWidth

	slog.Debug("addEmojis",
		slog.Int("totalemojis", totalEmojis),
		slog.Int("rows", rows),
		slog.Int("width", args.Width),
		slog.Int("transparent_spacing", defaultWidth-args.Width),
		slog.Int("totalWithTransparent", totalWithTransparent))

	if totalWithTransparent > maxStickersTotal {
		return nil, fmt.Errorf("–æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç–∏–∫–µ—Ä–æ–≤ (%d) —Å –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º–∏ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –º–∞–∫—Å–∏–º—É–º (%d)", totalWithTransparent, maxStickersTotal)
	}

	inputStickers := prepareInputStickers(ctx, b, args, emojiFileIDs, transparentData)
	return createStickerSetWithBatches(ctx, b, args, inputStickers)
}

// prepareInputStickers –ø–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å—Ç–∏–∫–µ—Ä–æ–≤ —Å —É—á–µ—Ç–æ–º –ø—Ä–æ–∑—Ä–∞—á–Ω—ã—Ö —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–µ–π
func prepareInputStickers(ctx context.Context, b *bot.Bot, args *EmojiCommand, emojiFileIDs []string, transparentData []byte) []models.InputSticker {
	transparentSpacing := defaultWidth - args.Width
	inputStickers := make([]models.InputSticker, 0, len(emojiFileIDs)*(1+transparentSpacing))

	if transparentSpacing > 0 {
		leftPadding := transparentSpacing / 2
		rightPadding := transparentSpacing - leftPadding

		for emojiIndex := 0; emojiIndex < len(emojiFileIDs); emojiIndex++ {
			pos := emojiIndex % args.Width

			// –î–æ–±–∞–≤–ª—è–µ–º –ª–µ–≤—ã–µ –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–µ —Å—Ç–∏–∫–µ—Ä—ã –≤ –Ω–∞—á–∞–ª–µ —Å—Ç—Ä–æ–∫–∏
			if pos == 0 {
				inputStickers = append(inputStickers, createTransparentStickers(ctx, b, args, transparentData, leftPadding)...)
			}

			// –î–æ–±–∞–≤–ª—è–µ–º —ç–º–æ–¥–∑–∏
			inputStickers = append(inputStickers, models.InputSticker{
				Sticker:   &models.InputFileString{Data: emojiFileIDs[emojiIndex]},
				Format:    defaultStickerFormat,
				EmojiList: []string{defaultEmojiIcon},
			})

			// –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–∞–≤—ã–µ –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–µ —Å—Ç–∏–∫–µ—Ä—ã –≤ –∫–æ–Ω—Ü–µ —Å—Ç—Ä–æ–∫–∏
			if pos == args.Width-1 || emojiIndex == len(emojiFileIDs)-1 {
				inputStickers = append(inputStickers, createTransparentStickers(ctx, b, args, transparentData, rightPadding)...)
			}
		}
	} else {
		// –ö–æ–≥–¥–∞ –Ω–µ –Ω—É–∂–Ω—ã –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–µ —Å—Ç–∏–∫–µ—Ä—ã, –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ —ç–º–æ–¥–∑–∏
		for _, fileID := range emojiFileIDs {
			inputStickers = append(inputStickers, models.InputSticker{
				Sticker:   &models.InputFileString{Data: fileID},
				Format:    defaultStickerFormat,
				EmojiList: []string{defaultEmojiIcon},
			})
		}
	}

	return inputStickers
}

// createTransparentStickers —Å–æ–∑–¥–∞–µ—Ç —É–∫–∞–∑–∞–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–∑—Ä–∞—á–Ω—ã—Ö —Å—Ç–∏–∫–µ—Ä–æ–≤
func createTransparentStickers(ctx context.Context, b *bot.Bot, args *EmojiCommand, transparentData []byte, count int) []models.InputSticker {
	stickers := make([]models.InputSticker, 0, count)

	for i := 0; i < count; i++ {
		transparentFileID, err := uploadSticker(ctx, b, args.UserID, "transparent.webm", transparentData)
		if err != nil {
			slog.Error("failed to upload transparent sticker", slog.String("error", err.Error()))
			continue
		}

		stickers = append(stickers, models.InputSticker{
			Sticker:   &models.InputFileString{Data: transparentFileID},
			Format:    defaultStickerFormat,
			EmojiList: []string{defaultEmojiIcon},
		})
		time.Sleep(time.Millisecond * 50)
	}

	return stickers
}

// createStickerSetWithBatches —Å–æ–∑–¥–∞–µ—Ç –Ω–∞–±–æ—Ä —Å—Ç–∏–∫–µ—Ä–æ–≤ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –±–∞—Ç—á–µ–π
func createStickerSetWithBatches(ctx context.Context, b *bot.Bot, args *EmojiCommand, inputStickers []models.InputSticker) (*models.StickerSet, error) {
	// –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –Ω–∞–±–æ—Ä —Å—Ç–∏–∫–µ—Ä–æ–≤ —Å –ø–µ—Ä–≤—ã–º —Å—Ç–∏–∫–µ—Ä–æ–º

	count := len(inputStickers)
	if count > maxStickersInBatch {
		count = maxStickersInBatch
	}

	ok, err := b.CreateNewStickerSet(ctx, &bot.CreateNewStickerSetParams{
		UserID:      args.UserID,
		Name:        args.PackLink,
		Title:       args.SetName,
		StickerType: "custom_emoji",
		Stickers:    inputStickers[:count],
	})
	if err != nil {
		slog.Debug("new sticker set FAILED", slog.String("name", args.PackLink), slog.String("error", err.Error()))
		return nil, fmt.Errorf("create sticker set: %w", err)
	}

	if !ok {
		return nil, fmt.Errorf("failed to create sticker set")
	}

	inputStickers = inputStickers[count:]

	// –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —Å—Ç–∏–∫–µ—Ä—ã –ø–æ –æ–¥–Ω–æ–º—É
	for i := 1; i < len(inputStickers); i++ {
		ok, err := b.AddStickerToSet(ctx, &bot.AddStickerToSetParams{
			UserID:  args.UserID,
			Name:    args.PackLink,
			Sticker: inputStickers[i],
		})

		if err != nil {
			return nil, fmt.Errorf("add sticker to set: %w", err)
		}

		if !ok {
			return nil, fmt.Errorf("failed to add sticker to set")
		}

		time.Sleep(time.Millisecond * 50)
	}

	// –ü–æ–ª—É—á–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–∞–±–æ—Ä–∞
	set, err := b.GetStickerSet(ctx, &bot.GetStickerSetParams{
		Name: args.PackLink,
	})
	if err != nil {
		return nil, fmt.Errorf("get sticker set: %w", err)
	}

	return set, nil
}

// addToExistingStickerSet –¥–æ–±–∞–≤–ª—è–µ—Ç —ç–º–æ–¥–∑–∏ –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –Ω–∞–±–æ—Ä
func addToExistingStickerSet(ctx context.Context, b *bot.Bot, args *EmojiCommand, emojiFileIDs []string, transparentData []byte) (*models.StickerSet, error) {
	// –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –Ω–∞–±–æ—Ä —Å—Ç–∏–∫–µ—Ä–æ–≤
	currentSet, err := b.GetStickerSet(ctx, &bot.GetStickerSetParams{
		Name: args.PackLink,
	})
	if err != nil {
		return nil, fmt.Errorf("get existing sticker set: %w", err)
	}

	totalEmojis := len(emojiFileIDs)
	rows := (totalEmojis + args.Width - 1) / args.Width
	totalWithTransparent := rows * defaultWidth

	slog.Debug("addEmojis",
		slog.Int("totalemojis", totalEmojis),
		slog.Int("rows", rows),
		slog.Int("width", args.Width),
		slog.Int("transparent_spacing", defaultWidth-args.Width),
		slog.Int("totalWithTransparent", totalWithTransparent))

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—Ä–µ–≤—ã—Å–∏–º –ª–∏ –ª–∏–º–∏—Ç —Å —É—á–µ—Ç–æ–º –ø—Ä–æ–∑—Ä–∞—á–Ω—ã—Ö —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–µ–π
	if len(currentSet.Stickers)+totalWithTransparent > maxStickersTotal {
		return nil, fmt.Errorf("–æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç–∏–∫–µ—Ä–æ–≤ (%d) —Å –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º–∏ –ø—Ä–µ–≤—ã—Å–∏—Ç –º–∞–∫—Å–∏–º—É–º (%d)",
			len(currentSet.Stickers)+totalWithTransparent, maxStickersTotal)
	}

	// –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∏–∫–µ—Ä—ã —Å –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º–∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏
	inputStickers := prepareInputStickers(ctx, b, args, emojiFileIDs, transparentData)

	// –î–æ–±–∞–≤–ª—è–µ–º –∫–∞–∂–¥—ã–π —Å—Ç–∏–∫–µ—Ä –ø–æ –æ—Ç–¥–µ–ª—å–Ω–æ—Å—Ç–∏
	for i, inputSticker := range inputStickers {
		ok, err := b.AddStickerToSet(ctx, &bot.AddStickerToSetParams{
			UserID:  args.UserID,
			Name:    args.PackLink,
			Sticker: inputSticker,
		})

		if err != nil {
			return nil, fmt.Errorf("add sticker to existing set (sticker %d): %w", i+1, err)
		}

		if !ok {
			return nil, fmt.Errorf("failed to add sticker %d to existing set", i+1)
		}
	}

	// –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –Ω–∞–±–æ—Ä —Å—Ç–∏–∫–µ—Ä–æ–≤
	updatedSet, err := b.GetStickerSet(ctx, &bot.GetStickerSetParams{
		Name: args.PackLink,
	})
	if err != nil {
		return nil, fmt.Errorf("get updated sticker set: %w", err)
	}

	return updatedSet, nil
}

func ColorToHex(colorName string) string {
	if colorName == "" {
		return ""
	}
	if hex, exists := colorMap[strings.ToLower(colorName)]; exists {
		return hex
	}

	// –ï—Å–ª–∏ —ç—Ç–æ —É–∂–µ hex —Ñ–æ—Ä–º–∞—Ç –∏–ª–∏ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ü–≤–µ—Ç, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å
	if strings.HasPrefix(colorName, "0x") {
		return colorName
	}

	return "0x000000" // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —á–µ—Ä–Ω—ã–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
}
